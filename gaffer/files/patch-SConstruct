--- SConstruct.orig	2025-08-28 19:52:07 UTC
+++ SConstruct
@@ -48,6 +48,7 @@ import codecs
 import tempfile
 import distutils.dir_util
 import codecs
+import string
 
 EnsureSConsVersion( 3, 0, 2 ) # Substfile is a default builder as of 3.0.2
 
@@ -405,11 +406,23 @@ env = Environment(
 
 	CPPPATH = [
 		"include",
+		"/usr/local/include",
+		"/usr/local/include/qt5",
+		"/usr/local/include/python3.11/",
+		"/usr/local/include/Imath/",
+		"/usr/local/include/oneapi/",
+		"/usr/local/include/freetype2",
+		"/usr/local/include/utils",
+		"/usr/local/include/third_party/atomic",
+		"/usr/local/share/openshadinglanguage/shaders",
 		"$LOCATE_DEPENDENCY_CPPPATH",
 	],
 
 	LIBPATH = [
 		"./lib",
+		"/usr/local/lib",
+		"/usr/local/lib/qt5",
+		"/usr/local/lib/qt5/bin",
 		"$BUILD_DIR/lib",
 		"$LOCATE_DEPENDENCY_LIBPATH",
 	],
@@ -429,7 +442,7 @@ for path in [
 		"$BUILD_DIR/include",
 		"$BUILD_DIR/include/Imath",
 		"$BUILD_DIR/include/GL",
-	] + env["LOCATE_DEPENDENCY_SYSTEMPATH"] :
+	] + str.split(env["LOCATE_DEPENDENCY_SYSTEMPATH"]) :
 
 	env.Append(
 		CXXFLAGS = [ systemIncludeArgument, path ]
@@ -465,6 +478,8 @@ if env["PLATFORM"] != "win32" :
 		env.Append( CXXFLAGS = [ "-DBOOST_NO_CXX98_FUNCTION_BASE", "-D_HAS_AUTO_PTR_ETC=0" ] )
 		env["GAFFER_PLATFORM"] = "macos"
 
+	if env["PLATFORM"] == "freebsd" :
+		env["GAFFER_PLATFORM"] = "freebsd"
 	else :
 
 		env["GAFFER_PLATFORM"] = "linux"
@@ -837,8 +852,8 @@ boostVersionHeader = baseLibEnv.FindFile(
 boostVersionHeader = baseLibEnv.FindFile(
 	"boost/version.hpp",
 	[ "$BUILD_DIR/include" ] +
-	baseLibEnv["LOCATE_DEPENDENCY_SYSTEMPATH"] +
-	baseLibEnv["LOCATE_DEPENDENCY_CPPPATH"]
+	split(baseLibEnv["LOCATE_DEPENDENCY_SYSTEMPATH"]) +
+	split(baseLibEnv["LOCATE_DEPENDENCY_CPPPATH"])
 )
 
 if not boostVersionHeader :
@@ -1600,12 +1615,13 @@ for library in ( "GafferUI", ) :
 			libraries[library]["envAppends"]["LIBS"].append( "Qt${QT_VERSION}" + qtLibrary )
 
 for library in ( "GafferUI", ) :
-	addQtLibrary( library, "Core", False )
+	addQtLibrary( library, "Core", False )	
 	addQtLibrary( library, "Gui" )
 	addQtLibrary( library, "OpenGL" )
 	addQtLibrary( library, "Test" )
 	addQtLibrary( library, "Widgets" )
 
+
 # Add required platform-specific libraries
 
 if env["PLATFORM"] == "win32" :
@@ -1839,7 +1855,7 @@ for libraryName, libraryDef in libraries.items() :
 	# command ourselves.
 
 	for sourceFile in libraryDef.get( "mocSourceFiles", [] ) :
-		mocOutput = commandEnv.Command( os.path.splitext( sourceFile )[0] + ".moc", sourceFile, "moc $SOURCE -o $TARGET" )
+		mocOutput = commandEnv.Command( os.path.splitext( sourceFile )[0] + ".moc", sourceFile, "moc-qt5 $SOURCE -o $TARGET" )
 		# Somehow the above leads to a circular dependency between `mocOutput` and itself.
 		# Tell SCons not to worry. The official SCons tool does the same.
 		env.Ignore( mocOutput, mocOutput )
@@ -1895,23 +1911,23 @@ for libraryName, libraryDef in libraries.items() :
 
 	# osl shaders
 
-	def buildOSL( target, source, env ) :
-		subprocess.check_call(
-			[
-				shutil.which( "oslc", path = env["ENV"]["PATH"] ) if env["PLATFORM"] == "win32" else "oslc",
-				"-I./shaders",
-				"-o",
-				str( target[0] ), str( source[0] )
-			],
-			env = env["ENV"]
-		)
+	#def buildOSL( target, source, env ) :
+	#	subprocess.check_call(
+	#		[
+	#			shutil.which( "/usr/local/bin/oslc", path = env["ENV"]["PATH"] ) if env["PLATFORM"] == "win32" else "oslc",
+	#			"-I./shaders",
+	#			"-o",
+	#			str( target[0] ), str( source[0] )
+	#		],
+	#		env = env["ENV"]
+	#	)
+	#
+	#for oslShader in libraryDef.get( "oslShaders", [] ) :
+	#	env.Alias( "buildCore", oslShader )
+	#	compiledFile = commandEnv.Command( os.path.join( installRoot, os.path.splitext( oslShader )[0] + ".oso" ), oslShader, buildOSL )
+	#		env.Depends( compiledFile, "oslHeaders" )
+	#	env.Alias( "buildCore", compiledFile )
 
-	for oslShader in libraryDef.get( "oslShaders", [] ) :
-		env.Alias( "buildCore", oslShader )
-		compiledFile = commandEnv.Command( os.path.join( installRoot, os.path.splitext( oslShader )[0] + ".oso" ), oslShader, buildOSL )
-		env.Depends( compiledFile, "oslHeaders" )
-		env.Alias( "buildCore", compiledFile )
-
 	# class stubs
 
 	def buildClassStub( target, source, env ) :
@@ -1937,56 +1953,6 @@ for libraryName, libraryDef in libraries.items() :
 
 	# USD Schemas
 
-	def buildSchema( target, source, env ) :
-
-		# Write a basic `plugInfo.json` file.
-
-		targetDir = os.path.dirname( str( target[0] ) )
-		libraryName = os.path.basename( targetDir )
-		with open( os.path.join( targetDir, "plugInfo.json" ), "w" ) as plugInfo :
-			plugInfo.write( inspect.cleandoc(
-				"""
-				{{
-					"Plugins" : [
-						{{
-							"Name" : "{libraryName}",
-							"Type" : "resource",
-							"Root" : ".",
-							"ResourcePath" : ".",
-							"Info" : {{ }}
-						}}
-					]
-				}}
-				""".format( libraryName = libraryName )
-			) )
-
-		# Then call `usdGenSchema` to write `generatedSchema.usda` and
-		# update `plugInfo.json` in place.
-
-		subprocess.check_call(
-			[
-				shutil.which( "python", path = commandEnv["ENV"]["PATH"] ),
-				# `shutil.which()` on Windows also returns executables that match the input so we
-				# strip the extension as we require the Python script rather than the wrapper.
-				shutil.which( "usdGenSchema", path = commandEnv["ENV"]["PATH"] ).rstrip( ".CMD" ),
-				str( source[0] ), targetDir
-			],
-			env = commandEnv["ENV"]
-		)
-
-	schemaSource = os.path.join( "usdSchemas", libraryName + ".usda" )
-	if os.path.isfile( schemaSource ) :
-		generatedSchema = commandEnv.Command(
-			[
-				os.path.join( installRoot, "plugin", libraryName, "generatedSchema.usda" ),
-				os.path.join( installRoot, "plugin", libraryName, "plugInfo.json" )
-			],
-			schemaSource,
-			buildSchema
-		)
-		commandEnv.Alias( "buildCore", generatedSchema )
-
-env.Alias( "build", "buildCore" )
 
 #########################################################################################################
 # Python nodes authored as Boxes and exported by ExtensionAlgo
