--- SConstruct.orig	2026-01-06 23:37:17 UTC
+++ SConstruct
@@ -48,6 +48,7 @@ import codecs
 import tempfile
 import distutils.dir_util
 import codecs
+import string
 
 EnsureSConsVersion( 3, 0, 2 ) # Substfile is a default builder as of 3.0.2
 
@@ -67,6 +68,7 @@ gafferVersionSuffix = "" # used for alpha/beta release
 gafferMinorVersion = 8 # new backwards-compatible features
 gafferPatchVersion = 0 # bug fixes
 gafferVersionSuffix = "" # used for alpha/beta releases : "a1", "b2", etc.
+QT_VERSION = 5
 
 # All of the following must be considered when determining
 # whether or not a change is backwards-compatible
@@ -405,11 +407,23 @@ env = Environment(
 
 	CPPPATH = [
 		"include",
+		"/usr/local/include",
+		"/usr/local/include/qt5",
+		"/usr/local/include/python3.11/",
+		"/usr/local/include/Imath/",
+		"/usr/local/include/oneapi/",
+		"/usr/local/include/freetype2",
+		"/usr/local/include/utils",
+		"/usr/local/include/third_party/atomic",
+		"/usr/local/share/openshadinglanguage/shaders",
 		"$LOCATE_DEPENDENCY_CPPPATH",
 	],
 
 	LIBPATH = [
 		"./lib",
+		"/usr/local/lib",
+		"/usr/local/lib/qt5",
+		"/usr/local/lib/qt5/bin",
 		"$BUILD_DIR/lib",
 		"$LOCATE_DEPENDENCY_LIBPATH",
 	],
@@ -429,7 +443,7 @@ for path in [
 		"$BUILD_DIR/include",
 		"$BUILD_DIR/include/Imath",
 		"$BUILD_DIR/include/GL",
-	] + env["LOCATE_DEPENDENCY_SYSTEMPATH"] :
+	] + (env["LOCATE_DEPENDENCY_SYSTEMPATH"] if isinstance(env["LOCATE_DEPENDENCY_SYSTEMPATH"], list) else [env["LOCATE_DEPENDENCY_SYSTEMPATH"]]) :
 
 	env.Append(
 		CXXFLAGS = [ systemIncludeArgument, path ]
@@ -465,6 +479,8 @@ if env["PLATFORM"] != "win32" :
 		env.Append( CXXFLAGS = [ "-DBOOST_NO_CXX98_FUNCTION_BASE", "-D_HAS_AUTO_PTR_ETC=0" ] )
 		env["GAFFER_PLATFORM"] = "macos"
 
+	if env["PLATFORM"] == "freebsd" :
+		env["GAFFER_PLATFORM"] = "freebsd"
 	else :
 
 		env["GAFFER_PLATFORM"] = "linux"
@@ -752,9 +768,9 @@ haveSphinx = conf.checkSphinx()
 
 haveSphinx = conf.checkSphinx()
 
-if not conf.checkQtVersion() :
-	sys.stderr.write( "Qt not found\n" )
-	Exit( 1 )
+#if not conf.checkQtVersion() :
+#	sys.stderr.write( "Qt not found\n" )
+#	Exit( 1 )
 
 ###############################################################################################
 # An environment for running commands with access to the applications we've built
@@ -821,7 +837,6 @@ baseLibEnv.Append(
 baseLibEnv.Append(
 
 	LIBS = [
-		"boost_filesystem$BOOST_LIB_SUFFIX",
 		"boost_regex$BOOST_LIB_SUFFIX",
 		"boost_chrono$BOOST_LIB_SUFFIX",
 		"tbb",
@@ -837,8 +852,8 @@ boostVersionHeader = baseLibEnv.FindFile(
 boostVersionHeader = baseLibEnv.FindFile(
 	"boost/version.hpp",
 	[ "$BUILD_DIR/include" ] +
-	baseLibEnv["LOCATE_DEPENDENCY_SYSTEMPATH"] +
-	baseLibEnv["LOCATE_DEPENDENCY_CPPPATH"]
+	split(baseLibEnv["LOCATE_DEPENDENCY_SYSTEMPATH"]) +
+	split(baseLibEnv["LOCATE_DEPENDENCY_CPPPATH"])
 )
 
 if not boostVersionHeader :
@@ -1038,13 +1053,26 @@ if env["GAFFERUSD"] :
 usdPythonLib = basePythonEnv.subst( "boost_python$BOOST_PYTHON_LIB_SUFFIX" )
 if env["GAFFERUSD"] :
 
+	systemPaths = baseLibEnv["LOCATE_DEPENDENCY_SYSTEMPATH"]
+	if not isinstance(systemPaths, list):
+    		systemPaths = [ systemPaths ]
+
+	cppPaths = baseLibEnv["LOCATE_DEPENDENCY_CPPPATH"]
+	if not isinstance(cppPaths, list):
+    		cppPaths = [ cppPaths ]
+
 	pxrVersionHeader = baseLibEnv.FindFile(
-		"pxr/pxr.h",
-		[ "$BUILD_DIR/include" ] +
-		baseLibEnv["LOCATE_DEPENDENCY_SYSTEMPATH"] +
-		baseLibEnv["LOCATE_DEPENDENCY_CPPPATH"]
+    	"pxr/pxr.h",
+    	[ "$BUILD_DIR/include" ] + systemPaths + cppPaths
 	)
 
+#	pxrVersionHeader = baseLibEnv.FindFile(
+#		"pxr/pxr.h",
+#		[ "$BUILD_DIR/include" ] +
+#		baseLibEnv["LOCATE_DEPENDENCY_SYSTEMPATH"] +
+#		baseLibEnv["LOCATE_DEPENDENCY_CPPPATH"]
+#	)
+
 	if not pxrVersionHeader :
 		sys.stderr.write( "ERROR : unable to find \"pxr/pxr.h\".\n" )
 		Exit( 1 )
@@ -1596,17 +1624,18 @@ def addQtLibrary( library, qtLibrary, pythonOnly = Tru
 		if not pythonOnly:
 			libraries[library]["envAppends"].setdefault( "FRAMEWORKS", [] ).append( "Qt" + qtLibrary )
 	else :
-		libraries[library]["pythonEnvAppends"]["LIBS"].append( "Qt${QT_VERSION}" + qtLibrary )
+		libraries[library]["pythonEnvAppends"]["LIBS"].append( "Qt5" + qtLibrary )
 		if not pythonOnly:
-			libraries[library]["envAppends"]["LIBS"].append( "Qt${QT_VERSION}" + qtLibrary )
+			libraries[library]["envAppends"]["LIBS"].append( "Qt5" + qtLibrary )
 
 for library in ( "GafferUI", ) :
-	addQtLibrary( library, "Core", False )
+	addQtLibrary( library, "Core", False )	
 	addQtLibrary( library, "Gui" )
 	addQtLibrary( library, "OpenGL" )
 	addQtLibrary( library, "Test" )
 	addQtLibrary( library, "Widgets" )
 
+
 # Add required platform-specific libraries
 
 if env["PLATFORM"] == "win32" :
@@ -1841,7 +1870,7 @@ for libraryName, libraryDef in libraries.items() :
 	# command ourselves.
 
 	for sourceFile in libraryDef.get( "mocSourceFiles", [] ) :
-		mocOutput = commandEnv.Command( os.path.splitext( sourceFile )[0] + ".moc", sourceFile, "moc $SOURCE -o $TARGET" )
+		mocOutput = commandEnv.Command( os.path.splitext( sourceFile )[0] + ".moc", sourceFile, "moc-qt5 $SOURCE -o $TARGET" )
 		# Somehow the above leads to a circular dependency between `mocOutput` and itself.
 		# Tell SCons not to worry. The official SCons tool does the same.
 		env.Ignore( mocOutput, mocOutput )
@@ -1897,23 +1926,23 @@ for libraryName, libraryDef in libraries.items() :
 
 	# osl shaders
 
-	def buildOSL( target, source, env ) :
-		subprocess.check_call(
-			[
-				shutil.which( "oslc", path = env["ENV"]["PATH"] ) if env["PLATFORM"] == "win32" else "oslc",
-				"-I./shaders",
-				"-o",
-				str( target[0] ), str( source[0] )
-			],
-			env = env["ENV"]
-		)
+	#def buildOSL( target, source, env ) :
+	#	subprocess.check_call(
+	#		[
+	#			shutil.which( "/usr/local/bin/oslc", path = env["ENV"]["PATH"] ) if env["PLATFORM"] == "win32" else "oslc",
+	#			"-I./shaders",
+	#			"-o",
+	#			str( target[0] ), str( source[0] )
+	#		],
+	#		env = env["ENV"]
+	#	)
+	#
+	#for oslShader in libraryDef.get( "oslShaders", [] ) :
+	#	env.Alias( "buildCore", oslShader )
+	#	compiledFile = commandEnv.Command( os.path.join( installRoot, os.path.splitext( oslShader )[0] + ".oso" ), oslShader, buildOSL )
+	#		env.Depends( compiledFile, "oslHeaders" )
+	#	env.Alias( "buildCore", compiledFile )
 
-	for oslShader in libraryDef.get( "oslShaders", [] ) :
-		env.Alias( "buildCore", oslShader )
-		compiledFile = commandEnv.Command( os.path.join( installRoot, os.path.splitext( oslShader )[0] + ".oso" ), oslShader, buildOSL )
-		env.Depends( compiledFile, "oslHeaders" )
-		env.Alias( "buildCore", compiledFile )
-
 	# class stubs
 
 	def buildClassStub( target, source, env ) :
@@ -1939,56 +1968,6 @@ for libraryName, libraryDef in libraries.items() :
 
 	# USD Schemas
 
-	def buildSchema( target, source, env ) :
-
-		# Write a basic `plugInfo.json` file.
-
-		targetDir = os.path.dirname( str( target[0] ) )
-		libraryName = os.path.basename( targetDir )
-		with open( os.path.join( targetDir, "plugInfo.json" ), "w" ) as plugInfo :
-			plugInfo.write( inspect.cleandoc(
-				"""
-				{{
-					"Plugins" : [
-						{{
-							"Name" : "{libraryName}",
-							"Type" : "resource",
-							"Root" : ".",
-							"ResourcePath" : ".",
-							"Info" : {{ }}
-						}}
-					]
-				}}
-				""".format( libraryName = libraryName )
-			) )
-
-		# Then call `usdGenSchema` to write `generatedSchema.usda` and
-		# update `plugInfo.json` in place.
-
-		subprocess.check_call(
-			[
-				shutil.which( "python", path = commandEnv["ENV"]["PATH"] ),
-				# `shutil.which()` on Windows also returns executables that match the input so we
-				# strip the extension as we require the Python script rather than the wrapper.
-				shutil.which( "usdGenSchema", path = commandEnv["ENV"]["PATH"] ).rstrip( ".CMD" ),
-				str( source[0] ), targetDir
-			],
-			env = commandEnv["ENV"]
-		)
-
-	schemaSource = os.path.join( "usdSchemas", libraryName + ".usda" )
-	if os.path.isfile( schemaSource ) :
-		generatedSchema = commandEnv.Command(
-			[
-				os.path.join( installRoot, "plugin", libraryName, "generatedSchema.usda" ),
-				os.path.join( installRoot, "plugin", libraryName, "plugInfo.json" )
-			],
-			schemaSource,
-			buildSchema
-		)
-		commandEnv.Alias( "buildCore", generatedSchema )
-
-env.Alias( "build", "buildCore" )
 
 #########################################################################################################
 # Python nodes authored as Boxes and exported by ExtensionAlgo
